interface Validator {
    (input: string): boolean;
}
interface Parser {
    (postcode: string): string | null;
}
declare class ValidPostcode {
    private instance;
    constructor(postcode: string);
    readonly valid: boolean;
    readonly postcode: string;
    readonly incode: string;
    readonly outcode: string;
    readonly area: string;
    readonly district: string;
    readonly subDistrict: string;
    readonly sector: string;
    readonly unit: string;
}
declare type InvalidPostcode = {
    valid: false;
    postcode: null;
    incode: null;
    outcode: null;
    area: null;
    district: null;
    subDistrict: null;
    sector: null;
    unit: null;
};
/**
 * Postcode
 *
 * This wraps an input postcode string and provides instance methods to
 * validate, normalise or extract postcode data.
 *
 * This API is a bit more cumbersome that it needs to be. You should
 * favour `Postcode.parse()` or a static method depending on the
 * task at hand.
 */
declare class Postcode {
    private _raw;
    private _valid;
    private _incode?;
    private _outcode?;
    private _area?;
    private _unit?;
    private _district?;
    private _subDistrict?;
    private _sector?;
    constructor(postcode: string);
    static isValid: Validator;
    static toNormalised: Parser;
    static toOutcode: Parser;
    static toIncode: Parser;
    static toArea: Parser;
    static toSector: Parser;
    static toUnit: Parser;
    static toDistrict: Parser;
    static toSubDistrict: Parser;
    static validOutcode(outcode: string): boolean;
    static parse(postcode: string): ValidPostcode | InvalidPostcode;
    valid(): boolean;
    incode(): string | null;
    outcode(): string | null;
    area(): string | null;
    district(): string | null;
    subDistrict(): string | null;
    sector(): string | null;
    unit(): string | null;
    normalise(): string | null;
}
export = Postcode;
