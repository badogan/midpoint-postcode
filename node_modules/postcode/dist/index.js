"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var ValidPostcode = /** @class */ (function () {
    function ValidPostcode(postcode) {
        this.instance = new Postcode(postcode);
    }
    Object.defineProperty(ValidPostcode.prototype, "valid", {
        get: function () {
            return this.instance.valid();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValidPostcode.prototype, "postcode", {
        get: function () {
            return this.instance.normalise();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValidPostcode.prototype, "incode", {
        get: function () {
            return this.instance.incode();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValidPostcode.prototype, "outcode", {
        get: function () {
            return this.instance.outcode();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValidPostcode.prototype, "area", {
        get: function () {
            return this.instance.area();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValidPostcode.prototype, "district", {
        get: function () {
            return this.instance.district();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValidPostcode.prototype, "subDistrict", {
        get: function () {
            return this.instance.subDistrict();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValidPostcode.prototype, "sector", {
        get: function () {
            return this.instance.sector();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValidPostcode.prototype, "unit", {
        get: function () {
            return this.instance.unit();
        },
        enumerable: true,
        configurable: true
    });
    return ValidPostcode;
}());
var invalidPostcode = {
    valid: false,
    postcode: null,
    incode: null,
    outcode: null,
    area: null,
    district: null,
    subDistrict: null,
    sector: null,
    unit: null
};
/**
 * Return first elem of input is RegExpMatchArray or null if input null
 */
var firstOrNull = function (match) {
    if (match === null)
        return null;
    return match[0];
};
var SPACE_REGEX = /\s+/gi;
/**
 * Drop all spaces and uppercase
 */
var sanitize = function (s) {
    return s.replace(SPACE_REGEX, "").toUpperCase();
};
var matchOn = function (s, regex) {
    return sanitize(s).match(regex);
};
var incodeRegex = /\d[a-z]{2}$/i;
var validOutcodeRegex = /^[a-z]{1,2}\d[a-z\d]?$/i;
var VALIDATION_REGEX = /^[a-z]{1,2}\d[a-z\d]?\s*\d[a-z]{2}$/i;
/**
 * Detects a "valid" postcode
 * - Starts and ends on a non-space character
 * - Any length of intervening space is allowed
 * - Must conform to one of following schemas:
 *  - AA1A 1AA
 *  - A1A 1AA
 *  - A1 1AA
 *  - A99 9AA
 *  - AA9 9AA
 *  - AA99 9AA
 */
var isValid = function (postcode) {
    return postcode.match(VALIDATION_REGEX) !== null;
};
/**
 * Returns a normalised postcode string (i.e. uppercased and properly spaced)
 *
 * Returns null if invalid postcode
 */
var toNormalised = function (postcode) {
    var outcode = toOutcode(postcode);
    if (outcode === null)
        return null;
    var incode = toIncode(postcode);
    if (incode === null)
        return null;
    return outcode + " " + incode;
};
/**
 * Returns a correctly formatted outcode given a postcode
 *
 * Returns null if invalid postcode
 */
var toOutcode = function (postcode) {
    if (!isValid(postcode))
        return null;
    return sanitize(postcode).replace(incodeRegex, "");
};
/**
 * Returns a correctly formatted incode given a postcode
 *
 * Returns null if invalid postcode
 */
var toIncode = function (postcode) {
    if (!isValid(postcode))
        return null;
    var match = matchOn(postcode, incodeRegex);
    return firstOrNull(match);
};
var AREA_REGEX = /^[a-z]{1,2}/i;
/**
 * Returns a correctly formatted area given a postcode
 *
 * Returns null if invalid postcode
 */
var toArea = function (postcode) {
    if (!isValid(postcode))
        return null;
    var match = matchOn(postcode, AREA_REGEX);
    return firstOrNull(match);
};
/**
 * Returns a correctly formatted sector given a postcode
 *
 * Returns null if invalid postcode
 */
var toSector = function (postcode) {
    var outcode = toOutcode(postcode);
    if (outcode === null)
        return null;
    var incode = toIncode(postcode);
    if (incode === null)
        return null;
    return outcode + " " + incode[0];
};
var UNIT_REGEX = /[a-z]{2}$/i;
/**
 * Returns a correctly formatted unit given a postcode
 *
 * Returns null if invalid postcode
 */
var toUnit = function (postcode) {
    if (!isValid(postcode))
        return null;
    var match = matchOn(postcode, UNIT_REGEX);
    return firstOrNull(match);
};
var DISTRICT_SPLIT_REGEX = /^([a-z]{1,2}\d)([a-z])$/i;
/**
 * Returns a correctly formatted district given a postcode
 *
 * Returns null if invalid postcode
 *
 * @example
 *
 * ```
 * toDistrict("AA9 9AA") // => "AA9"
 * toDistrict("A9A 9AA") // => "A9"
 * ```
 */
var toDistrict = function (postcode) {
    var outcode = toOutcode(postcode);
    if (outcode === null)
        return null;
    var match = outcode.match(DISTRICT_SPLIT_REGEX);
    if (match === null)
        return outcode;
    return match[1];
};
/**
 * Returns a correctly formatted subdistrict given a postcode
 *
 * Returns null if no subdistrict is available on valid postcode
 * Returns null if invalid postcode
 *
 * @example
 *
 * ```
 * toSubDistrict("AA9A 9AA") // => "AA9A"
 * toSubDistrict("A9A 9AA") // => "A9A"
 * toSubDistrict("AA9 9AA") // => null
 * toSubDistrict("A9 9AA") // => null
 * ```
 */
var toSubDistrict = function (postcode) {
    var outcode = toOutcode(postcode);
    if (outcode === null)
        return null;
    var split = outcode.match(DISTRICT_SPLIT_REGEX);
    if (split === null)
        return null;
    return outcode;
};
var returnNull = function () { return null; };
/**
 * Postcode
 *
 * This wraps an input postcode string and provides instance methods to
 * validate, normalise or extract postcode data.
 *
 * This API is a bit more cumbersome that it needs to be. You should
 * favour `Postcode.parse()` or a static method depending on the
 * task at hand.
 */
var Postcode = /** @class */ (function () {
    function Postcode(postcode) {
        this._raw = postcode;
        this._valid = isValid(postcode);
        // All parse methods should return null if invalid
        if (!this._valid) {
            this.incode = returnNull;
            this.outcode = returnNull;
            this.area = returnNull;
            this.district = returnNull;
            this.subDistrict = returnNull;
            this.sector = returnNull;
            this.unit = returnNull;
            this.normalise = returnNull;
        }
    }
    Postcode.validOutcode = function (outcode) {
        return outcode.match(validOutcodeRegex) !== null;
    };
    Postcode.parse = function (postcode) {
        if (isValid(postcode))
            return new ValidPostcode(postcode);
        return __assign({}, invalidPostcode);
    };
    Postcode.prototype.valid = function () {
        return this._valid;
    };
    Postcode.prototype.incode = function () {
        if (this._incode)
            return this._incode;
        return (this._incode = toIncode(this._raw));
    };
    Postcode.prototype.outcode = function () {
        if (this._outcode)
            return this._outcode;
        return (this._outcode = toOutcode(this._raw));
    };
    Postcode.prototype.area = function () {
        if (this._area)
            return this._area;
        return (this._area = toArea(this._raw));
    };
    Postcode.prototype.district = function () {
        if (this._district)
            return this._district;
        return (this._district = toDistrict(this._raw));
    };
    Postcode.prototype.subDistrict = function () {
        if (this._subDistrict)
            return this._subDistrict;
        return (this._subDistrict = toSubDistrict(this._raw));
    };
    Postcode.prototype.sector = function () {
        if (this._sector)
            return this._sector;
        return (this._sector = toSector(this._raw));
    };
    Postcode.prototype.unit = function () {
        if (this._unit)
            return this._unit;
        return (this._unit = toUnit(this._raw));
    };
    Postcode.prototype.normalise = function () {
        return this.outcode() + " " + this.incode();
    };
    Postcode.isValid = isValid;
    Postcode.toNormalised = toNormalised;
    Postcode.toOutcode = toOutcode;
    Postcode.toIncode = toIncode;
    Postcode.toArea = toArea;
    Postcode.toSector = toSector;
    Postcode.toUnit = toUnit;
    Postcode.toDistrict = toDistrict;
    Postcode.toSubDistrict = toSubDistrict;
    return Postcode;
}());
module.exports = Postcode;
//# sourceMappingURL=index.js.map